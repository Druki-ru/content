---
title: Ленивый строитель
slug: wiki/9/lazy-builder
metatags:
  title: 'Drupal 9: Ленивый строитель'
  description: 'Lazy Builder — отложенная обработка медленного или персонализированного кода.'
authors:
  - Niklan
---

**Ленивый строитель** (англ. «Lazy Builder») — API, позволяющий отложить обработку медленного кода не блокируя основной поток.

## Введение

PHP — не асинхронный язык, это означает что вся обработка производится последовательно и медленный код тормозит весь процесс.

Медленный код сильно сказывается на общей производительности сайта. Обычно подобные проблемы решаются кешированием, но бывает, что подобные вычисления нужно производить в рантайме или каждый раз выдавать новые данные, кеш тут уже не поможет, зато помогут ленивые строители.

<Aside>

Примеры ниже могут не иметь ничего с реальным применением и специально такие для упрощения понимания работы ленивых строителей.

</Aside>

Например, мы имеем следующий код:

```php
function foo_a(): void {
  echo '<p>Hello World!</p>';
}

function foo_b(): void {
  sleep(1000);
  echo '<p>Foo</p>';
}

function foo_c(): void {
  echo '<p>Bar</p>';
}

foo_a();
foo_b();
foo_c();
```

Результатом выполнения будет:

```html
<p>Hello World!</p>
<p>Foo</p>
<p>Bar</p>
```

Данный код будет выполняться минимум 1 секунду, так как в `foo_b()` находится `sleep()` на такой промежуток.

Ленивый строитель позволят объяснить Drupal что мы знаем о медленном коде или тех местах, где он может появиться. В нашем случае мы точно знаем что это `foo_b()`.

Пример, если бы мы встроили туда ленивый строитель.

```php
function foo_a(): void {
  echo '<p>Hello World!</p>';
}

function foo_b(): array {
  return [
    '#lazy_builder' => ['foo_b_lazy', []],
  ];
}

function foo_b_lazy(): string {
  sleep(1000);
  return '<p>Foo</p>';
}

function foo_c(): void {
  echo '<p>Bar</p>';
}

foo_a();
foo_b();
foo_c();
```

При подобном коде, Drupal бы прежде всего сформировал следующий результат (примерно):

```php
<p>Hello World!</p>
<drupal-render-placeholder callback="foo_b_lazy" arguments="" token="TOKEN"></drupal-render-placeholder>
<p>Bar</p>
```

На текущем этапе код отработает настолько быстро, насколько это возможно, потому что `foo_b()` теперь отдаёт ленивый строитель, а Drupal заменяет его на заполнитель `<drupal-render-placeholder>`.

По умолчанию, Drupal, в конце обработки запроса, перед самым ответом заменит все подобные заполнители реальными значениями и итоговый результат будет:

```html
<p>Hello World!</p>
<p>Foo</p>
<p>Bar</p>
```

Мы получим точно такой же результат, но код выполняется уже в другом порядке. Да, «от перестановки слагаемых сумма не меняется» и код по-прежнему будет обрабатываться минимум 1 секунду.

Ленивые строители отвечают только за подготовку разметки для медленного кода, затем обработка передаётся [стратегиям заполнителей](../placeholder-strategy/index.md) — которые и решают что делать с каждым конкретным заполнителем типа `<drupal-render-placeholder>`.

Drupal также поставляет модуль BigPipe, который предоставляет новую стратегию, основанную на одноимённом [подходе Facebook](https://medium.com/@arpingajjar/faster-web-page-loading-with-facebook-bigpipe-fbbc49b28959). В случае примера выше, пользователь получит ответ до того как `<drupal-render-placeholder>` будет заменён на результат. После того как ответ будет отправлен, Drupal дождётся завершения `foo_b_lazy()` и заменит заполнитель на странице пользователя без перезагрузок и дополнительных запросов. TTFB в таком случае будет равен тому, сколько нужно PHP на вызов `foo_a()` и `foo_c()` (<1ms), но итоговое время загрузки будет по-прежнему минимум секунду. Смотрите [пример](https://www.youtube.com/watch?v=JwzX0Qv6u3A) для визуального представления.

Вы можете [создавать свои стратегии](../placeholder-strategy/index.md) и подходы и комбинировать их для одной страницы.

## Структура ленивого строителя

Ленивый строитель — рендер массив с ключом `#lazy_builder` при помощи которого передаётся информация о том, как необходимо обрабатывать его и что возвращает значение. По сути, мы указываем функцию обратного вызова и аргументы для неё, которую необходимо вызывать, когда Drupal вызовет обработку данного кода.

Рендер массив с описанием ленивого строителя может иметь только следующие свойства:

- `#lazy_builder`: Массив описывающий ленивый строитель.
- `#create_placeholder`: Принимает логическое значения, необходимо ли создавать заполнитель для текущего ленивого строителя. По умолчанию отключено.
- `#cache`: Для передачи кеш метаданных.
- `#attached`: Для подключения [библиотек](../libraries/index.md) или более комплексного ленивого строителя.
- `#weight`: Вес элемента, если это требуется, например в [Form API](../forms/index.md).

Данный рендер массив не может содержать никаких иных свойств и вложенных массивов. Нарушение данного правила приведёт к вызову исключения.

### lazy_builder

Свойство `#lazy_builder` — массив, содержащий массив с функцией обратного вызова и массивом из аргументов, которые необходимо передать функции обратного вызова.

Пример:

```php
$build = [
  '#lazy_builder' => [
    'Foo::bar', ['Hello', 'World'],
  ],
];
```

Подобная запись равняется `Foo::bar('Hello', 'World')`.

**Функцией обратного вызова** может быть:

- PHP функции обратного вызова ([callable](https://www.php.net/manual/ru/language.types.callable.php)).
- Сервисы в формате `{service_name}:{method}`.

**Аргументами** для функции обратного вызова могут быть только [скалярные значения](https://www.php.net/manual/ru/function.is-scalar.php) (`int`, `float`, `string`, `bool`, `NULL`).

> [!WARNING]
> Аргументы для ленивых строителей могут быть видны в исходном коде страницы. Не передавайте через них важные или компрометирующие данные, если это требуется, передавайте их через какое-либо хранилище с уникальными ID, которое доступно только бэкенду.

### create_placeholder

Логическое свойство `#create_placeholder` отвечает за то, будет ли создан заполнитель для текущего ленивого строителя.

По умолчанию, ленивый строитель не создаёт заполнитель и сразу выполняет код. Это сделано для того, чтобы вы могли размечать потенциально медленные части кода, где неизвестно, будет ли медленный код или нет.

При отсутствии данного значения, Drupal предпримет попытку автоматического определения, требуется ли использовать ленивый вызов и добавлять заполнитель. Данное определение происходит на основе кеш-метаданных (`#cache`) переданных в рендер массиве ленивого строителя и настройки `renderer.config:auto_placeholder_conditions`.

<Aside type="tip">

Вы можете менять данные настройки в `sites/default/default.services.yml` файле или иметь разные для разных окружений.

</Aside>

По умолчанию данные настройки имеют следующие значения:

- `max-age` равный `0`: Заполнитель будет создаваться если `max-age` меньше или равен данному значению.
- `contexts` равный `session` и `user`: Заполнитель будет создаваться если в кеш-метаданных есть один из этих кеш-контекстов.
- `tags` с пустым массивом: Заполнители по умолчанию не реагирую на кеш-теги.

Если вы хотите чтобы ваш ленивый строитель всегда работал, укажите `#create_placeholder` равным `TRUE`, в таком случае все условия и автоматизация будет пропущена и рендер массив гарантированно будет обработан лениво.

Пример:

```php
$build = [
  '#create_placeholder' => TRUE,
  '#lazy_builder' => [
    'Foo::bar', ['Hello', 'World'],
  ],
];
```

### attached

Свойство `#attached` также может быть использовано для создания ленивых строителей. На самом деле, именно так информация о ленивых строителях и передается если вы будете использовать `#lazy_builder` и `#create_placeholder`.

Данный подход будет полезен в тех случаях, когда вы хотите влиять на то, какой должен быть заполнитель, особенно в случаях, когда вы хотите использовать разные [стратегии заполнителей](../placeholder-strategy/index.md) на одной странице, или отделять свои стратегии от стандартных.

При данном подходе, информация о ленивых строителях передаётся через ключ массива `placeholders`, который может содержать массивы где:

- Ключ массива — фактический заполнитель.
- Значение — массив с описанием ленивого строителя.

Пример:

```php
$build = [
  '#markup' => 'Hello <span class="my-placeholder"></span> World!',
  '#attached' => [
    'placeholders' => [
      '<span class="my-placeholder"></span>' => [
        '#lazy_builder' => [
          'Foo::bar', ['Hello', 'World'],
        ],
      ],
    ],
  ],
];
```

> [!IMPORTANT]
> Заполнитель из примера не будет работать по умолчанию, так как Drupal ничего не знает о таком формате заполнителя. Для подобного подхода требуется наличие [стратегии заполнителя](../placeholder-strategy/index.md), которая понимает подобный формат.

## Изменения в релизах

* **[Drupal 9.2.0](../../releases/9/9.2.x/9.2.0/index.md) (02.06.2021):** Система рендера теперь выбрасывает исключение, если в качестве результата функции обратного вызова возвращается что-то отличное от рендер массива.

## Ссылки

- [Drupal 8: #lazy_builder — ленивый билдер](https://niklan.net/blog/154), Niklan, 2017
- [Плагин блока, генерящий динамический контент с помощью #lazy_builder](http://xandeadx.ru/blog/drupal/992), xandeadx, 2021
